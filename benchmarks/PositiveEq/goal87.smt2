(set-logic HORN)

(declare-datatype Nat ((Z) (S (nextnat Nat))))
(declare-datatype Tree ((leaf) (node (trn1 Nat) (ltree Tree) (rtree Tree))))
(declare-datatype Lst ((nil) (cons (car Nat) (cdr Lst))))
(declare-datatype Lst2 ((nil2) (cons2 (car1 Nat) (car2 Nat) (cdr2 Lst2))))
(declare-datatype Queue ((queue (queue1 Lst) (queue2 Lst))))


(declare-fun add (Nat Nat Nat) Bool)
(declare-fun lt (Nat Nat) Bool)
(declare-fun le (Nat Nat) Bool)
(declare-fun gt (Nat Nat) Bool)
(declare-fun ge (Nat Nat) Bool)
(assert (forall ((y Nat)) (add Z y y)))
(assert (forall ((x Nat) (y Nat) (z Nat)) (=> (add x y z) (add (S x) y (S z)))))
(assert (forall ((y Nat)) (lt Z (S y))))
(assert (forall ((x Nat) (y Nat)) (=> (lt x y) (lt (S x) (S y)))))
(assert (forall ((x Nat) (y Nat)) (=> (or (lt x y) (= x y)) (le x y))))
(assert (forall ((x Nat)) (gt (S x) Z)))
(assert (forall ((x Nat) (y Nat)) (=> (gt x y) (gt (S x) (S y)))))
(assert (forall ((x Nat) (y Nat)) (=> (or (gt x y) (= x y)) (ge x y))))

(declare-fun zappend
             (Lst2 Lst2 Lst2)
             Bool)
(declare-fun len (Lst Nat) Bool)
(declare-fun zip (Lst Lst Lst2) Bool)
(declare-fun rev (Lst Lst) Bool)
(declare-fun zrev (Lst2 Lst2) Bool)
(declare-fun incorrect () Bool)
(declare-fun append (Lst Lst Lst) Bool)
(assert (forall ((A Lst) (B Lst)) (=> (= A nil) (append A B B))))
(assert (forall ((A Nat)
         (B Lst)
         (C Lst)
         (D Lst)
         (E Lst)
         (F Lst))
  (=> (and (append B E C) (= F (cons A C)) (= D (cons A B))) (append D E F))))
(assert (forall ((A Lst2) (B Lst2))
  (=> (= A nil2) (zappend A B B))))
(assert (forall ((A Nat)
         (B Nat)
         (C Lst2)
         (D Lst2)
         (E Lst2)
         (F Lst2)
         (G Lst2))
    (=> (and (zappend C F D)
                  (= E (cons2 A B C))
                  (= G (cons2 A B D))) (zappend E F G))))
(assert (forall ((A Lst) (B Lst))
  (=> (and (= B nil) (= A nil)) (rev A B))))
(assert (forall ((A Nat)
         (B Lst)
         (C Lst)
         (D Lst)
         (E Lst)
         (F Lst))
  (=> (and (append C D F) (rev B C) (= D (cons A nil)) (= E (cons A B)))
      (rev E F))))
(assert (forall ((A Lst2) (B Lst2))
  (=> (and (= B nil2) (= A nil2)) (zrev A B))))
(assert (forall ((A Nat)
         (B Nat)
         (C Lst2)
         (D Lst2)
         (E Lst2)
         (F Lst2)
         (G Lst2))
    (=> (and (zappend D E G)
                  (zrev C D)
                  (= F (cons2 A B C))
                  (= E (cons2 A B nil2))) (zrev F G))))
(assert (forall ((A Lst) (B Nat)) (=> (and (= B Z) (= A nil)) (len A B))))
(assert (forall ((A Nat) (B Lst) (C Nat) (D Lst) (E Nat))
  (=> (and (len B C) (= D (cons A B)) (add (S Z) C E)) (len D E))))
(assert (forall ((A Lst) (B Lst) (C Lst2))
  (=> (and (= A nil) (= C nil2)) (zip A B C))))
(assert (forall ((A Nat)
         (B Lst)
         (C Lst)
         (D Lst)
         (E Lst2))
  (=> (and (= C (cons A B)) (= E nil2) (= D nil)) (zip C D E))))
(assert (forall ((A Nat)
         (B Lst)
         (C Nat)
         (D Lst)
         (E Nat)
         (F Lst)
         (G Nat)
         (H Lst)
         (I Nat)
         (J Nat)
         (K Lst)
         (L Nat)
         (M Nat)
         (N Lst)
         (O Lst)
         (P Lst)
         (Q Lst2)
         (R Lst)
         (S Lst)
         (T Lst2))
    (=> (and (zip O P Q)
                  (= S (cons M N))
                  (= T (cons2 L M Q))
                  (= R (cons L K))
                  (= S (cons J P))
                  (= R (cons I O))
                  (= S (cons G H))
                  (= R (cons E F))
                  (= S (cons C D))
                  (= R (cons A B))) (zip R S T))))
(assert (forall ((A Lst)
         (B Nat)
         (C Lst)
         (D Lst)
         (E Lst)
         (F Lst2)
         (G Lst2)
		 (K1 Nat)
		 (K2 Nat)
         (H Lst2))
  (=> (and (zrev G H)
           (len A B)
           (rev A D)
           (zip A C G)
           (len C B)
           (rev C E)
           (zip D E F)
           (= F (cons2 K1 K2 H)))					;;
      incorrect)))
(assert (=> incorrect false))
(check-sat)

